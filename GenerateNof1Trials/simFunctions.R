##############################################
# Simulation Functions for N-of-1 Project
# Number of Blocks for Sequential Monitoring
# 
# Subodh Selukar
# 2021-03-03
##############################################

# -------------------------------- Description ------------------------------------------------ #

##### This simulation study is intended to describe 
##### early stopping with sequential monitoring boundaries 
##### for N-of-1 trials with 2 treatments

#### Goal is to assess number of blocks/periods 
#### needed for consequential early stopping 
#### across various effect sizes and monitoring rules (stop times and boundary types)

##### Analysis is done with linear mixed effects model
##### with random intercepts (i.e., exchangeable correlation)
##### Uses Wald statistic from REML (less biased estimate of SE than ML) 

##### That model is true: 
##### data are generated as independent blocks
##### each with input L periods

##### The periods may have correlation, so blcoks are generated 
##### via mvtnorm package

#### NOTE: Simulation is required rather than numerical results 
#### because (1) treatment assignment is random 
#### (not computationally efficient to look across
#### all possible combinations of within-block and between-block
#### treatment sequences)
#### otherwise, could use numerical integration of density
#### and (2) using observed information to calculate test statistics
#### other results show that, with small samples, observed
#### vs. expected information may greatly affect properties

#### Requires packages:
# 1. gtools (generate treatment sequences)
# 2. mvtnorm (generate data)
# 3. lme4 (analyze data)
# 4. gsDesign (monitoring boundaries)

# -------------------------------- Functions ------------------------------------------------ #

### Function to simulate data for one (n-of-1) trial
## 1. generate the treatment assignments 
## 2. construct fixed design matrix and covariance matrix
## 3. simulate one trial

## Inputs:
# 1. numPeriods: number of periods per block
#   NOTE: currently, must be multiple of 2 because balanced treatment frequency within  blocks
# 2. numBlocks: number of independent blocks 
# 3. fixIntercept: fixed effect under "control" (default to 0, do not plan on changing)
# 4. fixSlope: fixed treatment effect
# 5. randVar: Random effect variance (i.e., within-block covariance) (default to 1)
# 6. errVar: Error variance (default to 1, do not plan on changing)
# 7. inSeqs: matrix of possible sequences for periods within a block 
#   each row is possible sequence (not simulation input: generated by simData function by numPeriods/numBlocks/timeBlock arguments)

## Output: 
# Dataframe with names y (outcome vector), trt (treatment assignment) with nrow()=numPeriods*numBlocks
simOneTrial <- function(numPeriods,
                        numBlocks,
                        fixIntercept,
                        fixSlope,
                        randVar,
                        errVar,
                        inSeqs){
  fixParams <- c(fixIntercept,fixSlope)
  
  ### generate treatment assignments
  blockSeqs <- sample(1:nrow(inSeqs),numBlocks,replace=TRUE) # indicates which of the sequences used for each of the blocks; assignments may be repeated
  trtAsns <- c(t(inSeqs[blockSeqs,])) # converts the sequences above to a vector of the assignments for the full trial
  
  ### construct fixed design matrix and covariance matrix
  fixDesignMat <- cbind(rep(1,numPeriods*numBlocks),trtAsns)
  
  blockCovar <- errVar*diag(numPeriods)+randVar*matrix(1,nrow=numPeriods,ncol=numPeriods)
  trialCovar <- diag(numBlocks) %x% blockCovar
  
  ### simulate one trial
  y <- rmvnorm(1,
               mean=(fixDesignMat %*% fixParams),
               sigma=trialCovar
  )
  return(cbind(block=rep(1:numBlocks,each=numPeriods),y=c(y),trt=trtAsns))
}

### Function to simulate data for all trials in a simulation set (calls simOneTrial)
## Inputs: 
# 1. numTrials: number of trials to simulate (default to 1 for testing)
# 2. timeBlock: binary variable to indicate whether 
#   sequences must be ABBA/BAAB-type to account for time confounding,
#   or if other sequences are also acceptable 
#   (defaults to FALSE, not currently supported)
# 3+. arguments for simOneTrial

## Output:
# array with dim()=c(numPeriods*numBlocks,3,numTrials)
# one layer for each trial, each layer has 3 columns (y, trt and block, inherited from simOneTrial) and numPeriods*numBlocks rows
simData <- function(numTrials=1,
                    timeBlock=FALSE,
                    numPeriods=4,
                    numBlocks=3,
                    fixIntercept=0,
                    fixSlope=1,
                    randVar=1,
                    errVar=1){
  
  if (numPeriods %% 2 != 0 ) stop("Unbalanced treatment frequency within blocks")
  
  ### generate possible treatment sequences for each block
  tmpSeqs <- permutations(numPeriods,numPeriods,
                          c(rep(0,numPeriods/2),rep(1,numPeriods/2)),
                          set=FALSE) # calculates all possible sequences (with some duplicates)
  posSeqs <- tmpSeqs[!duplicated(tmpSeqs),]
  
  if (timeBlock){
    stop("Not supported") # need to figure out how to select only the time confounding sequences from posSeqs
  } else {
    inSeqs <- posSeqs
  }
  
  ### call simOneTrial
  out <- replicate(numTrials, 
                   simOneTrial(numPeriods,
                               numBlocks,
                               fixIntercept,
                               fixSlope,
                               randVar,
                               errVar,
                               inSeqs))
  
  return(out)
}

### Function to run (analyze) one trial
## analyze data at all prespecified times in loop

## Inputs:
# 1. datIn: full trial data (expects a dataframe with colnames block, y, trt)
# 2. stopTimes: vector of stopping times (i.e., blocks after which analysis conducted)
#   NOTE: stopTimes[1] == 1 throws error due to lme4 not fitting with k=1;
#   also need stopTimes increasing

## Output: vector of length = 2*length(stopTimes) 
# concatenates the pairs of (estimate, standard error) across all stopTimes

runOneTrial <- function(datIn,
                        stopTimes){
  if (stopTimes[1]==1 | any(diff(stopTimes) < 0)) stop("Misspecified analysis time vector")
  
  datIn <- as.data.frame(datIn)
  anaList <- vector("list",length(stopTimes))  # will hold all of the analyses in case it's desired later
  out <- rep(NA,2*length(stopTimes))
  for (anaIdx in 1:length(stopTimes)){
    tmpDat <- datIn[datIn$block <= stopTimes[anaIdx],] # analysis dataset (all blocks cumulatively until analysis time)
    anaList[[anaIdx]] <- lmer(y~trt+(1|block),data=tmpDat,REML = TRUE) # LMM with random intercepts by block
    
    out[((anaIdx-1)*2+1):(anaIdx*2)] <- summary(anaList[[anaIdx]])$coefficients[2,1:2]
  }
  
  return(out)
}


### Function to run one set of simulations (calls simData, runOneTrial)
## Inputs: 
# 1. simSeed: simulation seed (defaults to 2021, do not plan on changing)
# 2+. Arguments passed to simData and runOneTrial functions

## Output: List containing
# 1. Array inherited from simData with colnames block, y, trt, nrow=numBlocks*numPeriods and nlayers=numTrials
# 2. Matrix with columns for the estimate and standard error at each stopTime (inherited from runOneTrial) and nrow=numTrials

runSimSet <- function(simSeed=2021,
                      numTrials=3,
                      timeBlock=FALSE,
                      numPeriods,
                      numBlocks,
                      fixIntercept=0,
                      fixSlope,
                      randVar=1,
                      errVar=1,
                      stopTimes=NULL){
  ### generate simulation data
  set.seed(simSeed)
  fullDat <- simData(numTrials,
                     timeBlock,
                     numPeriods,
                     numBlocks,
                     fixIntercept,
                     fixSlope,
                     randVar,
                     errVar)
  
  if (is.null(stopTimes)) stopTimes <- 2:numBlocks # default to calculate statistics after every block
  
  ### analyze each dataset
  out <- matrix(nrow=numTrials,ncol=2*length(stopTimes))
  for (sim in 1:numTrials){
    tmpDat <- fullDat[,,sim]
    out[sim,] <- runOneTrial(tmpDat,stopTimes)
  }
  
  return(list(fullDat,
              out))
}


# -------------------------------- Not Used ------------------------------------------------ #


